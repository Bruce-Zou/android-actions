#include <stdio.h>#include <stdlib.h>#include <string.h>#include <pthread.h>#include "Actbuffer.h"#include "omx_comp_debug_levels.h"#include "log.h"#define ALIGN_SIZES  64/*0x08*/#define ALIGN_MASK  0xffffffc0/*0xfffffff8*/#define STRUCT_BLOCK_SIZE  sizeof(block_s)/*64bytes对齐*/typedef struct{	unsigned int ui_size;	int used;	int reserved[14];}block_s;typedef struct{	void *pool_buf;	void *pool_buf_phy;	unsigned int pool_size;	unsigned int v_chunk_size;	int available_size;	void *wr_ptr;   //point to buffer_to_write	void *wr_ptr_phy;	void *pool_buf_end;  //point to pool_buffer end	void *pool_buf_end_phy;	pthread_mutex_t mutex;	pthread_cond_t wbuf_cond;	int isCodaStop;   //component给coda发送CODA_STOP命令时，此时不用再编码和获取outputBuffer地址	int isSigalWait;	int allocNum;}pool_s;int pool_open(unsigned int ui_size,void** pool){	void* phy_addr = NULL;	unsigned long vir_addr = 0;	pool_s* pool_ptr;	int result;	pool_ptr = (pool_s*)malloc(sizeof(pool_s));	if(NULL == pool_ptr)	{		DEBUG(DEB_LEV_ERR,"err!malloc fail!%s,%d\n",__FILE__,__LINE__);		return -1;	}	ui_size = (ui_size + ALIGN_SIZES - 1) & ALIGN_MASK;	ui_size += 5 * STRUCT_BLOCK_SIZE;	phy_addr = omx_malloc_phy(ui_size,&vir_addr);	if(NULL == phy_addr)	{		DEBUG(DEB_LEV_ERR,"err!omx_malloc_phy fail!%s,%d\n",__FILE__,__LINE__);		free(pool_ptr);		return -1;	}	/*初始化*/	pool_ptr->pool_buf = (void *)vir_addr;	pool_ptr->pool_buf_phy = phy_addr;	pool_ptr->wr_ptr = pool_ptr->pool_buf;	pool_ptr->wr_ptr_phy = pool_ptr->pool_buf_phy;	pool_ptr->pool_size = ui_size;	pool_ptr->available_size = ui_size;	pool_ptr->v_chunk_size = 1024*1024;	pool_ptr->isCodaStop = 0;	pool_ptr->isSigalWait = 0;	pool_ptr->allocNum = 0;	pool_ptr->pool_buf_end = (void*)((unsigned char*)(pool_ptr->pool_buf) + pool_ptr->pool_size);	pool_ptr->pool_buf_end_phy = (void*)((unsigned char*)(pool_ptr->pool_buf_phy) + pool_ptr->pool_size);	result = pthread_mutex_init(&pool_ptr->mutex,NULL);	if(result != 0)	{		return -1;	}	result = pthread_cond_init(&pool_ptr->wbuf_cond,NULL);	if(result != 0)	{		return -1;	}	*pool = (void*)pool_ptr;	return 0;}void pool_dispose(void* pool){	pool_s* pool_ptr = (pool_s*)pool;	if(pool_ptr)	{		//if(pool_ptr->pool_buf)		if(pool_ptr->pool_buf_phy)		{			//free(pool_ptr->pool_buf);//ion			//pool_ptr->pool_buf = NULL;			omx_free_phy(pool_ptr->pool_buf_phy);			pool_ptr->pool_buf_phy = NULL;			pool_ptr->pool_buf = NULL;		}		pthread_mutex_destroy(&pool_ptr->mutex);		pthread_cond_destroy(&pool_ptr->wbuf_cond);		free(pool_ptr);		pool_ptr = NULL;	}}int get_poolsize(void* pool){	pool_s* pool_ptr = (pool_s*)pool;	return pool_ptr->pool_size;}unsigned char* get_poolbase(void* pool){	pool_s* pool_ptr = (pool_s*)pool;	return pool_ptr->pool_buf;}void* get_wbuf(void* pool,int size){	//printf("get_wbuf,size:%x\n",size);	pool_s* pool_ptr = (pool_s*)pool;	block_s* pBlock;	int result,end_space,loop=0;//size from wr_ptr to buffer end	if(size <= 0)		size = (int)pool_ptr->v_chunk_size;	size += STRUCT_BLOCK_SIZE;	/*若申请的空间比缓冲池的最大可用空间还要大则返回申请不成功*/	if((int)pool_ptr->pool_size < size)	{		return NULL;	}	end_space = (int)((unsigned char*)pool_ptr->pool_buf_end - (unsigned char*)pool_ptr->wr_ptr);	/*若reach the end of fifo list*/	if(end_space < size)	{		pool_ptr->available_size -= end_space;		if(pool_ptr->available_size < 0 || pool_ptr->available_size > (int)pool_ptr->pool_size)		{			return NULL;		}		pool_ptr->wr_ptr = pool_ptr->pool_buf;		pool_ptr->wr_ptr_phy = pool_ptr->pool_buf_phy;	}	/*不断申请buffer,直到buffer申请成功*/	result = pthread_mutex_lock(&pool_ptr->mutex);	if(result != 0)	{		return NULL;	}	while(1)	{		if(pool_ptr->isCodaStop == 1)		{			pthread_mutex_unlock(&pool_ptr->mutex);			return NULL;		}		if(pool_ptr->available_size >= size)			break;		pool_ptr->isSigalWait = 1;		result = pthread_cond_wait(&pool_ptr->wbuf_cond,&pool_ptr->mutex);		if(result != 0)		{			pthread_mutex_unlock(&pool_ptr->mutex);			return NULL;		}	}	result = pthread_mutex_unlock(&pool_ptr->mutex);	if(result != 0)	{		return NULL;	}	/*已经找到所用的buffer,生成block*/	pBlock = (block_s*)pool_ptr->wr_ptr;	pBlock->ui_size = size - STRUCT_BLOCK_SIZE;	pBlock->used = 0;	return (void*)((unsigned long)pool_ptr->wr_ptr + STRUCT_BLOCK_SIZE);}void* get_wbuf_phy(void* pool){	pool_s* pool_ptr = (pool_s*)pool;	return ((unsigned char*)pool_ptr->wr_ptr_phy) + STRUCT_BLOCK_SIZE;}int move_wptr(void* pool,int size){	int ret = 0;	int retp = 0;	pool_s* pool_ptr = 	(pool_s*)pool;	block_s* pBlock = NULL;	retp = pthread_mutex_lock(&pool_ptr->mutex);	if(retp != 0)	{		return -1;	}	pBlock = (block_s*)pool_ptr->wr_ptr;	size = (size + ALIGN_SIZES - 1) & ALIGN_MASK;	pBlock->ui_size = size;	pBlock->used = 1;	//printf("move_wptr,b4 pool_ptr->available_size:%x\n",pool_ptr->available_size);	pool_ptr->available_size -= (size + STRUCT_BLOCK_SIZE);	//printf("move_wptr,aft pool_ptr->available_size:%x\n",pool_ptr->available_size);	//printf("pool move on size: %d,available_size: %d\n",size+STRUCT_BLOCK_SIZE,pool_ptr->available_size);	if(pool_ptr->available_size < 0 || pool_ptr->available_size > (int)pool_ptr->pool_size)	{		ret = -1;		goto ERR;	}	pool_ptr->wr_ptr = (void*)((unsigned char*)(pool_ptr->wr_ptr) + size + STRUCT_BLOCK_SIZE);	pool_ptr->wr_ptr_phy = (void*)((unsigned char*)(pool_ptr->wr_ptr_phy) + size + STRUCT_BLOCK_SIZE);	if((pool_ptr->wr_ptr < pool_ptr->pool_buf) ||(pool_ptr->wr_ptr > pool_ptr->pool_buf_end))	{		ret = -1;		goto ERR;	}	retp = pthread_mutex_unlock(&pool_ptr->mutex);	if(retp != 0)	{		return -1;	}	return 0;ERR:    retp = pthread_mutex_unlock(&pool_ptr->mutex);	if(retp != 0)	{		return -1;	}	return ret;}void free_wbuf(void* pool,void* ptr,int allocLen){	//printf("free_wbuf,size:%x\n",allocLen);	pool_s* pool_ptr = (pool_s*)pool;	block_s* pBlock = (block_s*)((unsigned long)ptr - STRUCT_BLOCK_SIZE);	if(pool_ptr->isCodaStop == 1)		return;	if(pBlock->used == 1 && pBlock->ui_size != 0)	{		int result,size,end_space;		result = pthread_mutex_lock(&pool_ptr->mutex);		if(result != 0)		{			return;		}		pBlock->used = 0;		size = pBlock->ui_size;		size = ((size + ALIGN_SIZES - 1) & ALIGN_MASK) + STRUCT_BLOCK_SIZE;		end_space = (unsigned long)pool_ptr->pool_buf_end - (unsigned long)ptr - size;		if(end_space < allocLen)		{				size += (end_space+STRUCT_BLOCK_SIZE);		}		//printf("free_wbuf,b4 pool_ptr->available_size:%x\n",pool_ptr->available_size);		pool_ptr->available_size += size;		//printf("free_wbuf,aft pool_ptr->available_size:%x\n",pool_ptr->available_size);		pool_ptr->isSigalWait = 0;		result = pthread_cond_signal(&pool_ptr->wbuf_cond);		if(result != 0)		{			pthread_mutex_unlock(&pool_ptr->mutex);			return;		}		result = pthread_mutex_unlock(&pool_ptr->mutex);		if(result != 0)		{			return;		}	}}int clearBufferPool(void* pool){	int result;	pool_s* pool_ptr = (pool_s*)pool;	result = pthread_mutex_lock(&pool_ptr->mutex);	if(result != 0)	{		return -1;	}	pool_ptr->isCodaStop = 1;	if(pool_ptr->isSigalWait == 1)	{		pool_ptr->isSigalWait = 0;		result = pthread_cond_signal(&pool_ptr->wbuf_cond);		if(result != 0)		{			pthread_mutex_unlock(&pool_ptr->mutex);			return -1;		}	}	result = pthread_mutex_unlock(&pool_ptr->mutex);	if(result != 0)	{		return -1;	}	return 0;}